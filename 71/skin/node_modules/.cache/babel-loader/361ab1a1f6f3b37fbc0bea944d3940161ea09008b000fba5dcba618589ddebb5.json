{"ast":null,"code":"import { useState, useEffect, useRef, useMemo, useCallback } from 'react';\nimport memoize from 'lodash.memoize';\n\n/**\n * Custom hook to generate text using the Pollinations API.\n * \n * This hook encapsulates the logic for making a POST request to the Pollinations text generation API,\n * handling memoization, and cleaning the received markdown data.\n * \n * @param {string} prompt - The user's input prompt for text generation.\n * @param {Object} options - Configuration options for text generation.\n * @param {number} [options.seed=-1] - Seed for deterministic text generation. -1 for random.\n * @param {string} [options.systemPrompt] - Optional system prompt to guide the text generation.\n * @param {boolean} [options.jsonMode=false] - Whether to parse the response as JSON.\n * @param {boolean} [options.loadNull=false] - Whether to reset the text state to null before fetching new data.\n * @returns {Object} - An object containing the generated text and loading state.\n */\nconst usePollinationsText = (prompt, options = {}) => {\n  // Destructure options with default values\n  const {\n    seed = 42,\n    systemPrompt,\n    model,\n    jsonMode = false,\n    loadNull = false\n  } = options;\n\n  // State to hold the generated text\n  const [text, setText] = useState(null);\n\n  // Ref to track the current fetch request\n  const currentFetchRef = useRef(Promise.resolve());\n\n  // Memoized request body\n  const requestBody = useMemo(() => {\n    const messages = systemPrompt ? [{\n      role: \"system\",\n      content: systemPrompt\n    }] : [];\n    messages.push({\n      role: \"user\",\n      content: prompt\n    });\n    return {\n      messages,\n      seed,\n      model,\n      jsonMode\n    };\n  }, [prompt, systemPrompt, seed, model, jsonMode]);\n\n  // Memoized fetch function\n  const fetchText = useCallback(() => {\n    currentFetchRef.current = currentFetchRef.current.then(() => memoizedFetchPollinationsText(requestBody)).then(cleanedData => {\n      setText(cleanedData);\n    }).catch(error => {\n      console.error(\"Error in usePollinationsText:\", error);\n      setText(`An error occurred while generating text: ${error.message}. Please try again.`);\n    });\n  }, [requestBody]);\n\n  // Effect to fetch or retrieve memoized text\n  useEffect(() => {\n    if (prompt === null) return;\n    if (loadNull) setText(null);\n    fetchText();\n  }, [fetchText, loadNull, prompt]);\n  return text;\n};\n\n/**\n * Function to fetch text from the Pollinations API.\n * \n * @param {Object} requestBody - The request body for the API call.\n * @returns {Promise<string|Object>} - A promise that resolves to the cleaned text data or parsed JSON.\n */\nconst fetchPollinationsText = async requestBody => {\n  try {\n    const response = await fetch('https://text.pollinations.ai/', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(requestBody)\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.text();\n    return requestBody.jsonMode ? JSON.parse(data) : cleanMarkdown(data);\n  } catch (error) {\n    console.error(\"Error fetching text from Pollinations API:\", error);\n    throw error;\n  }\n};\n\n// Memoized version of fetchPollinationsText\nconst memoizedFetchPollinationsText = memoize(fetchPollinationsText, JSON.stringify);\n\n/**\n * Helper function to clean markdown data.\n * \n * This function extracts text between triple backticks, which is typically\n * used to denote code blocks in markdown. If no such block is found,\n * it returns the original data.\n * \n * @param {string} data - The markdown data to clean.\n * @returns {string} - The cleaned text data.\n */\nconst cleanMarkdown = data => {\n  const match = data.match(/```([\\s\\S]*?)```/);\n  return match ? match[1] : data;\n};\nexport default usePollinationsText;","map":{"version":3,"names":["useState","useEffect","useRef","useMemo","useCallback","memoize","usePollinationsText","prompt","options","seed","systemPrompt","model","jsonMode","loadNull","text","setText","currentFetchRef","Promise","resolve","requestBody","messages","role","content","push","fetchText","current","then","memoizedFetchPollinationsText","cleanedData","catch","error","console","message","fetchPollinationsText","response","fetch","method","headers","body","JSON","stringify","ok","Error","status","data","parse","cleanMarkdown","match"],"sources":["C:/Users/varsh/OneDrive/Desktop/71/skin/node_modules/@pollinations/react/src/hooks/usePollinationsText.js"],"sourcesContent":["import { useState, useEffect, useRef, useMemo, useCallback } from 'react';\nimport memoize from 'lodash.memoize';\n\n/**\n * Custom hook to generate text using the Pollinations API.\n * \n * This hook encapsulates the logic for making a POST request to the Pollinations text generation API,\n * handling memoization, and cleaning the received markdown data.\n * \n * @param {string} prompt - The user's input prompt for text generation.\n * @param {Object} options - Configuration options for text generation.\n * @param {number} [options.seed=-1] - Seed for deterministic text generation. -1 for random.\n * @param {string} [options.systemPrompt] - Optional system prompt to guide the text generation.\n * @param {boolean} [options.jsonMode=false] - Whether to parse the response as JSON.\n * @param {boolean} [options.loadNull=false] - Whether to reset the text state to null before fetching new data.\n * @returns {Object} - An object containing the generated text and loading state.\n */\nconst usePollinationsText = (prompt, options = {}) => {\n    // Destructure options with default values\n    const { seed = 42, systemPrompt, model, jsonMode = false, loadNull = false } = options;\n\n    // State to hold the generated text\n    const [text, setText] = useState(null);\n\n    // Ref to track the current fetch request\n    const currentFetchRef = useRef(Promise.resolve());\n\n    // Memoized request body\n    const requestBody = useMemo(() => {\n        const messages = systemPrompt ? [{ role: \"system\", content: systemPrompt }] : [];\n        messages.push({ role: \"user\", content: prompt });\n        return { messages, seed, model, jsonMode };\n    }, [prompt, systemPrompt, seed, model, jsonMode]);\n\n    // Memoized fetch function\n    const fetchText = useCallback(() => {\n        currentFetchRef.current = currentFetchRef.current\n            .then(() => memoizedFetchPollinationsText(requestBody))\n            .then(cleanedData => {\n                setText(cleanedData);\n            })\n            .catch((error) => {\n                console.error(\"Error in usePollinationsText:\", error);\n                setText(`An error occurred while generating text: ${error.message}. Please try again.`);\n            });\n    }, [requestBody]);\n\n    // Effect to fetch or retrieve memoized text\n    useEffect(() => {\n        if (prompt === null) return;\n        if (loadNull) setText(null);\n        fetchText();\n    }, [fetchText, loadNull, prompt]);\n\n    return text;\n};\n\n/**\n * Function to fetch text from the Pollinations API.\n * \n * @param {Object} requestBody - The request body for the API call.\n * @returns {Promise<string|Object>} - A promise that resolves to the cleaned text data or parsed JSON.\n */\nconst fetchPollinationsText = async (requestBody) => {\n    try {\n        const response = await fetch('https://text.pollinations.ai/', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(requestBody),\n        });\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.text();\n        return requestBody.jsonMode ? JSON.parse(data) : cleanMarkdown(data);\n    } catch (error) {\n        console.error(\"Error fetching text from Pollinations API:\", error);\n        throw error;\n    }\n};\n\n// Memoized version of fetchPollinationsText\nconst memoizedFetchPollinationsText = memoize(fetchPollinationsText, JSON.stringify);\n\n/**\n * Helper function to clean markdown data.\n * \n * This function extracts text between triple backticks, which is typically\n * used to denote code blocks in markdown. If no such block is found,\n * it returns the original data.\n * \n * @param {string} data - The markdown data to clean.\n * @returns {string} - The cleaned text data.\n */\nconst cleanMarkdown = (data) => {\n    const match = data.match(/```([\\s\\S]*?)```/);\n    return match ? match[1] : data;\n};\n\nexport default usePollinationsText;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}